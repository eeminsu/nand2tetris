# 컴퓨터 아키텍처 요약

## 1. 내장식 프로그램
- 컴퓨터는 정해진 명령어 집합들을 실행하는 고정된 하드웨어 플랫폼에 기반
- 컴퓨터가 실행하는 명령어들은 기본 블록이 되어 무한히 복잡한 프로그램으로 조합
- 프로그램들은 하드웨어에 내장되지 않음
- 프로그램의 코드는 컴퓨터 메모리상에 데이터처럼 저장되고 연산되는데 이것을 '소프트웨어'라 함
</br></br>

## 2. 폰 노이만 구조
- 폰 노이만 기계는 현대의 대부분 컴퓨터 플랫폼의 개념적 설계도이자 실제 구조
- CPU를 기반으로 하여 메모리 장치와 통신, 입력 장치에서 데이터를 받고, 출력장치에 데이터를 보내는 일을 함
- 이 장치에서 메모리는 컴퓨터가 조작하는 데이터 뿐 아니라 컴퓨터가 수행하는 명령어도 저장

### 2-1. 메모리
- 데이터와 명령어 두 정보의 기능은 다르지만 **동일한 무작위 접근 구조**에 **2진수로 저장**된다는 공통점이 있음
- 이 구조는 Word나 위치라고 불리는 정해진 크기의 셀들이 배열된 것
- 각각의 셀들은 유일한 주소를 가짐
- 따라서 개별 단어들은 그 주소로 특정할 수 있음

#### 데이터 메모리
- 고수준 프로그램은 변수, 배열, 객체같은 추상적 개념을 다룸
- 이러한 데이터를 번역하면 2진 숫자열로 바뀌어 데이터 메모리에 저장
- 주소를 통해 데이터 메모리에서 한 Word를 선택하여 읽기나 쓰기가 가능

#### 명령어 메모리
- 고수준 명령들을 기계어로 번역하면 각각 2진수 기계어 명령어를 뜻하는 단어가 됨
- 이 명령어들은 컴퓨터의 명령어 메모리에 저장
- 컴퓨터 연산의 각 단계마다 CPU는 명령어 메모리에서 Word하나를 fetch(읽기)하고 해석한 후에 정해진 명령을 수행한 후 다음에 실행할 명령어를 찾음
- 위와 같은 이유로 명령어 메모리의 내용을 바꾸면 컴퓨터 연산이 완전히 바뀌게 됨
- 명령어 메모리에 상주하는 명령어는 **기계어**로 작성
</br></br>

### 2-2. 중앙 처리 장치(CPU)
- 프로그램의 명령어를 실행하는 일을 담당
- 명령어들을 통해 다양한 계산을 수행
- 메모리에 값을 읽거나 쓰고 조건에 따른 다른 명령어로 점프
- 이런 작업을 수행하는데 3가지 주요 하드웨어가 관여
- **Word를 메모리에서 fetch하고, 해석하고, 실행하고, 다음 명령어를 fetch하는 루프가 반복**됨
- 명령어가 실행될 때는 ALU에서 어떤 값을 계산하고, 내부 레지스터를 조작하고, 메모리에서 Word를 읽고, Word를 쓰는 작업들 중 하나 이상을 하게 됨
- CPU는 위 과정을 실행하는 과정에서 다음에 fetch하고 실행할 명령어를 찾는 작업을 함

#### 산술 논리 연산 장치(ALU)
- 컴퓨터에서 지원하는 모든 **저수준 산술 연산** 및 **논리 연산**을 수행하는 장치

#### 레지스터
- CPU는 간단한 계산을 빠르게 수행하도록 설계
- 계산 성능을 올리기 위해선 결과를 매번 메모리에 로드하고 저장하기 보단 CPU 근처에 저장할 필요가 있음
- 모든 CPU는 Word 하나를 저장할 수 있는 고속 레지스터들을 약간씩 갖추고 있음

#### 제어 장치
- 명령어 하나가 실행 되려면 명령어를 해석해서 다양한 하드웨어 장치(ALU, 레지스터, 메모리)가 명령을 어떻게 실행해야 하는지 정보를 알아내고 각각에 전달해야 함
- **명령어 해석**은 제어 장치에서 이루어진다.
- 동시에 **어떤 명령어를 fetch하고 다음에 실행해야 하는지 알아내는 역할**도 함
</br></br>

### 2-3. 레지스터
- 메모리 접근은 느린 작업
- CPU가 메모리 주소 j의 내용을 가져오라는 지시를 받으면 다음과 같은 과정이 진행
  - j가 CPU에서 RAM으로 전달
  - RAM의 직접 접근 논리에 따라 주소가 j인 메모리 레지스터 선택
  - RAM[j]의 내용이 CPU로 다시 전달
- **레지스터는** 데이터 추출 및 저장기능은 RAM과 동일하나 **데이터가 왔다갔다하고 메모리를 탐색하는데 비용이 들지 않음**
- 레지스터는 **CPU 칩 내부에 물리적으로 위치**하므로 거의 **바로 접근이 가능**
- 메모리 **셀**은 거의 수백만 개가 있지만 레티스터는 **소수만 있음**
- 따라서 조작할 레지스터를 지정하는 데 몇 개의 비트만 필요하므로 명령어 길이도 짧게 됨
- CPU들은 여러 용도로 여러 가지 종류의 레지스터를 각각 다른 개수만큼 사용
- 어떤 컴퓨터 아키텍처에서는 다음과 같이 레지스터가 하나 이상의 기능을 수행

#### 데이터 레지스터
- CPU의 단기 기억 메모리 기능

#### 주소 지정 레지스터
- CPU는 데이터를 읽고 쓰기 위해 계속해서 메모리에 접근
- 연산마다 접근할 메모리에 단어를 지정(주소를 제공)
- 주소를 얻기 위해 예전 명령어의 실행 결과를 이용할 수 있음
- 위와 같은 경우에서 주소 지정 레지스터에 주소가 될 값을 저장

#### 프로그램 계수기 레지스터(PC)
- 메모리에서 fetch해야할 다음 명령어의 주소를 저장
- CPU는 현재 실행하는 명령어에 goto문이 없는 경우 PC의 값을 다음 명령을 가리키도록 증가시킴
- goto n 문이 있는 경우에는 PC에 n 값을 로드
</br></br>

### 2-4. 입력과 출력
- 컴퓨터는 매우 다양한 I/O장치를 통해 외부환경과 통신
- 이런 장치들을 이해하기 위해선 개별적인 기술지식이 필요하기 때문에 컴퓨터에서 완전히 똑같이 처리할 수 있는 기법을 고안
- 이 기법중 하나가 메모리 매핑 I/O(Memory-mapped I/O)
- I/O 장치를 에뮬레이션해서 CPU에게 그 장치를 마치 일반적인 메모리 세그먼트처럼 보이도록 하는 것
- 각 I/O 장치마다 메모리 내에 전용 영역이 할당되어 '메모리 맵'역할을 하게 됨
- 입력 장치의 경우 메모리 맵은 **지속적으로 장치의 물리적 상태를 반영**하도록 되어있음
- 출력 장치의 경우에는 **지속적으로 장치의 물리적 상태를 구동**하도록 만들어짐
- H/W 측면에서는 I/O 장치들은 메모리 장치와 유사한 인터페이스를 제공해야 함
- S/W 측면에서는 각 I/O 장치에 통신 규약을 정의해서 프로그램이 올바르게 접근할 수 있도록 해야함
- **새로운 I/O 장치를 컴퓨터에 연결할 때** 마다 그저 그 장치를 **새로운 메모리 맵에 할당**하고 **시작 주소를 메모**해두기만 하면 됨(보통 운영체제가 이런 1회성 환경설정을 담당)


